{
  "hash": "f72d139e58b873b4ad08eb3b298f2cdc",
  "result": {
    "markdown": "---\ntitle: \"Making sense of spatial density estimation\"\nauthor: \"Jon Zelner\"\ndate: \"1/23/2023\"\ncategories:\n  - code\n  - tutorial\n  - statistics\n  - spatial\n  - R\nimage: kde_example.png\nbibliography: refs.bib\n---\n\n\nWhen working with spatial data, our analytic task often falls into either of two rough categories.\n\n1. *Estimating local averages of a continuous variable.* This could be something like neighborhood-by-neighborhood variation in average blood pressure or the intensity of some kind of environmental risk factor such as the intensity of fine (e.g. $PM_{2.5}$) dust which can cause respiratory illness.\n\n2. *Estimating the local density of or incidence of a particular outcome.* For example, if we are trying to understand spatial variation in the incidence of a particular disease, we are interested in knowing how many cases of that disease are present in a given location or are likely to be present in some nearby unobserved location.\n\nIn this tutorial, we'll dig into the problem of spatial density estimation in one dimension along a spatial *transect*. The techniques discussed here form the basis of a number of approaches for cluster or hotspot analysis. For examples of smoothing local values of a continuous variable, check out [this tutorial](/posts/smoothing/index.qmd).\n\n## A motivating example\n\nA spatial transect is an area of space along a line crossing a landscape. These are often used in ecology and forestry to assess the health of an environment, species diversity and other factors. Using a transect can help simplify the problem of spatial analysis down to one dimension rather than the usual two, while still providing a tremendous amount of useful information. \n\n![Example of an ecological transect from the US National Park Service ([source](https://www.nps.gov/articles/000/what-are-transects.htm))](transect.png.png){width=60%}\n\nFor example, [@levy2014] were interested in characterizing the intensity of exposure to triatomine bugs and other insect vectors of the pathogen *T. cruzi*, which causes Chagas disease. \n\n![*Triatoma* (left- and right-hand panels) and *T. cruzi* (center) ([source](https://www.cdc.gov/parasites/chagas/index.html))](triatomine.png.png){width=60%}\n\n![Intensity of *Triatomine* infestation along a 2km transect in Arequipa, Peru (Figure from @levy2014)](levy-chagas.png.png)  \n\nImagine we are estimating the density of some unknown insect vector along a 1 kilometer transect with the goal of characterizing the risk of infection with a vector-borne illness. \n\n## Kernel density estimation in one dimension\n\nMuch like in our discussion of [kernel smoothing of continuous outcomes](/posts/smoothing/index.qmd), kernel functions play a key role in this setting as well. In this case, imagine that the locations of vectors along our transect have been sampled at random from some unknown function $f(x)$ which takes values from 0 (the beginning of the transect) to 1000m (the end).\n\nWe can use the Kernel function $K(d)$ to approximate the intensity of the outcome of interest at each observed case location $x_i$. Imagine that our observed data have locations $x_1, x_2, \\ldots, x_n$ and that the distance between our point of interest, $x_j$ and each observed point is $d_{ij} = | x_j - x_i |$.\n\nFinally, lets include a bandwidth parameter, $h$, which controls the width of the window we will use for smoothing. When we put this all together, we can get an estimate of the density of our outcome of interest at location $x_j$ as follows:\n\n$$\n\\hat{f_h}(x_j) = \\frac{1}{n} \\sum_{i=1}^{n} K(\\frac{x_j - x_i}{h})\n$$\n\nAs you can see below, we can pick a range of kernel functions, but for the sake of simplicity, in this example, we will focus in on a Gaussian, or normal, kernel, which uses the probability density function of a normal distribution to weight points. \n\nLets start by sampling locations of observed points along a one dimensional line. To keep things interesting, we'll use a Gaussian mixture distribution with two components:\n\n\n![Comparison of different kernel functions ([source](https://teazrq.github.io/SMLR/kernel-smoothing.html#choice-of-kernel-functions))](kernel-comparison.png){width=60%}  \n\n\n## Worked example\n\nFirst, lets imagine a scenario in which the risk of observing an insect vector steadily decreases as we walk along our transect. However, along the way there is a *hotspot* of increased risk beyond what we would expect from the smooth decline before and after that spot. For the purpose of this example, we'll assume that risk decays *exponentially* with distance from the origin, but that our hotspot is centered at a point 300 meters into the transect. The code below lets us sample the *locations* of the points along the transect where üêú are observed from two distributions:\n\n1. An exponential distribution representing smooth decay from the beginning to the end of the transect, and\n\n2. A normal distribution representing a hotspot about 150m in width beginning 300m in\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Sample from two intensity distributions\nc <- 500 ## Number of total cases\np_hot <- 0.2 ## Proportion of cases in the hotspot \nc_hot <- rbinom(1, c, p_hot) ## Sample the exact number of hotspot cases\nc_not <- c-c_hot ## The number of non-hotspot cases.\nx_a <- rexp(c_not, rate = 1/250) ## Sample the locations of non-hotspot cases\nx_b <- rnorm(c_hot, mean = 300, sd = 50) ## Sample the locations of hotspot cases\nx <- c(x_a, x_b) ## Vector of all hotspot locations\nojs_define(sample=x)\n```\n:::\n\n\n<!-- ```{ojs} -->\n<!-- import {Histogram} from \"@d3/histogram\" -->\n<!-- Histogram(sample, { -->\n<!--   width, -->\n<!--   thresholds: 100, -->\n<!--   domain: [0, 1000], -->\n<!--   color: \"steelblue\", -->\n<!--   height: 240 -->\n<!-- }) -->\n<!-- ``` -->\n\nThe figure below shows a histogram of locations sampled from $f(x)$ (vertical bars) overlaid with the true value of $f(x)$ in red:\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nlibrary(ggplot2)\nd_a <- dexp(1:1000, rate = 1/250) \nd_b <- dnorm(1:1000, mean = 300, sd = 50)\ny <- ((1-p_hot))*d_a + (p_hot*d_b)\n\ndens_df <- data.frame(x = 1:1000, y = y)\nxdf <- data.frame(x=x)\n\n\ng <- ggplot(xdf) + geom_histogram(aes(x=x, y=..density..), bins=100) + \ngeom_line(data=dens_df, aes(x=x,y=y), colour=\"red\") +\nxlim(0, 1000) + ylab(\"Density\") + xlab(\"Distance from transect origin (m)\")\nplot(g)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-2-1.png){width=672}\n:::\n:::\n\n\nNow, imagine we have another set of finely spaced points along the line, and for each, we want to calculate the weight for each. The function below lets us do that:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnormal_smoother <- function(x, h = 10, delta = 1, xmin = 1, xmax = 1000) {\n\n  ## Make a vector with the input points\n  xj <- seq(xmin, xmax, by = delta)\n\n  ## Make an empty vector to store the densities\n  xdens <- rep(0, length(xj))\n\n  for (j in 1:length(xj)) {\n    ## This calculates the density at this point while accounting for potential edge effects\n    xdens[j] <- mean(dnorm((xj[j]-x), sd=h)/(1-pnorm(0, mean = xj[j], sd=h)))\n  }\n\n  ## Package everything in a dataframe to return\n  df <- data.frame(x=xj, y=xdens)\n\n  return(df)\n\n}\n```\n:::\n\n\nThe figure below shows the true value of our density function $f(x)$ in red, the density of points in the simulated data along the x-axis of the 'rug plot', and our smoothed density in black, for a bandwidth of $h=10$:\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nlibrary(ggplot2)\npred_df <- normal_smoother(x, h = 10)\n\ng <- ggplot() + geom_rug(aes(x=x)) + \ngeom_line(data = pred_df, aes(x=x, y=y)) + \nylab(\"Density\") + geom_line(data = dens_df, aes(x=x,y=y), colour=\"red\") + \nxlim(0, 1000)\n\nplot(g)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-4-1.png){width=672}\n:::\n:::\n\n\nNow, lets see what happens if we try this for different values of $h$:\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nall_df <- data.frame()\nfor (hv in c(5, 10, 20, 50 ,100, 250)) {\n  pred_df <- normal_smoother(x, h = hv)\n  pred_df$h <- hv\n  all_df <- rbind(all_df, pred_df) \n}\n\n  all_df$h <- as.factor(all_df$h)\n\n\ng <- ggplot(all_df) + geom_rug(aes(x=x)) + \ngeom_line(data = dens_df, aes(x=x,y=y), colour=\"red\") + \ngeom_line(aes(x=x, y=y)) + \nylab(\"Density\") + \nfacet_wrap(~ h) +\nxlim(0, 1000)\n\nplot(g)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n\n\n### Questions\n\n- Which of the bandwidth options seems to do the best job in capturing the value of $f(x)$? Why?\n\n\n## Additional Resources\n\nPlease see Matthew Conlen's excellent [interactive KDE tutorial](https://mathisonian.github.io/kde/)\n\n## References",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<script type=\"ojs-define\">\n{\"contents\":[{\"name\":\"sample\",\"value\":[211.0774,187.3768,215.2115,638.6742,49.7776,439.6734,111.2312,85.8452,102.6971,417.3476,199.373,308.4282,15.9619,7.0882,121.0255,617.3543,163.0555,14.9995,137.9435,433.59,325.0398,76.816,1244.863,7.2127,119.9681,92.4341,13.506,633.947,74.6047,222.7953,263.2672,66.6697,28.4518,514.3326,245.0135,201.6915,118.1311,482.7371,259.4255,420.9249,199.2382,3.8708,1238.6471,381.7833,17.9202,213.5954,158.6172,81.2468,1088.193,45.5973,205.2426,366.3206,522.2437,136.6762,78.5767,216.2512,20.924,227.637,585.0098,303.5396,33.4234,212.9396,572.6715,163.4442,46.9654,257.3325,0.2779,24.152,71.6071,169.4524,539.8633,385.8621,66.9765,60.659,914.1016,151.818,288.0484,181.889,822.1178,127.7966,17.5692,46.2659,53.0803,154.0651,184.0825,12.1606,212.8673,57.0494,957.1696,700.9273,308.6822,201.5663,47.6005,460.615,28.9027,109.8266,371.0479,335.1133,221.2684,216.6631,284.2523,102.2986,89.5946,536.0608,92.4051,162.0071,48.282,264.9851,93.9515,357.4517,37.681,286.3181,393.7447,286.0758,635.3431,406.8761,44.244,334.759,237.538,291.487,354.959,219.54,177.1303,20.7357,203.3368,76.9375,7.6937,89.5415,249.2865,107.0835,122.8519,245.2012,571.5113,210.2339,971.1335,543.3885,237.3889,38.8533,311.0116,5.0972,295.6232,165.1597,156.2527,8.9143,193.1611,74.9781,93.9607,468.83,80.7434,175.7582,181.2009,357.0544,534.8348,554.9702,60.9495,208.9522,38.9932,100.8903,64.2603,132.12,168.3499,467.9324,139.4795,195.5485,10.3501,217.7141,79.4653,412.699,108.9494,351.9832,116.6436,496.6619,50.514,53.2814,61.0653,476.9834,444.134,232.0371,214.3319,159.4225,15.9494,76.7754,552.0332,210.5692,64.3378,919.9852,201.6152,855.8116,63.1732,719.0167,7.0717,100.8146,434.0977,58.8563,542.6108,250.6936,39.415,48.9831,119.1285,495.915,131.9716,141.4798,112.1119,267.2913,113.2398,581.5136,63.927,745.1791,16.5517,703.1811,448.4775,210.3859,265.1,56.64,32.8859,9.1589,217.5643,466.7557,301.0817,267.4019,811.041,531.3324,71.2029,12.224,218.6682,259.4464,178.5706,764.6083,1273.146,302.8239,8.3922,32.8561,191.7809,101.717,964.0019,620.8522,12.3652,349.6751,33.3918,216.2237,394.1671,115.9038,1025.2526,543.7866,301.7957,433.2457,856.4566,113.5273,411.602,169.8983,82.9565,38.3105,121.9051,188.9832,417.524,63.5784,498.6586,64.9614,118.2675,286.7304,199.3338,191.6475,330.3902,45.731,225.6523,44.5694,248.9896,178.3321,289.0193,332.5143,186.9285,107.6341,241.2303,76.277,488.3366,68.8972,81.3953,21.9066,646.3146,2.5699,234.9831,446.5957,644.0393,204.7833,26.6387,94.4527,659.6858,433.9697,472.3946,528.6236,35.1304,55.9558,195.4644,25.2746,144.7041,130.6683,1041.3018,258.8718,224.4176,498.9641,213.9613,837.2398,59.6783,1257.7146,156.6558,283.654,8.7548,417.9294,65.8714,205.5959,472.9322,129.0244,127.9792,475.3379,51.4892,203.4439,149.7923,19.4893,499.5825,319.0705,150.3322,157.6819,241.4389,412.515,691.9914,209.1088,415.2466,299.2582,30.2835,63.683,269.1571,760.2162,465.4839,78.8353,785.2656,59.6678,474.9262,459.4189,888.6724,696.1874,160.6017,112.3845,694.3071,572.8889,115.6961,157.9514,172.8814,105.8901,188.5989,326.5148,19.8229,96.4525,305.198,1.8449,191.2515,108.1728,192.2375,41.6215,31.5845,87.0354,353.5195,206.3931,34.9998,191.7796,287.3658,162.7806,8.7524,583.4197,294.734,8.9272,244.8565,165.7051,419.3656,180.2606,766.2617,85.7069,53.4493,18.117,146.6084,209.6053,882.6321,279.6762,802.7966,149.1288,6.7876,36.8859,284.4151,184.4963,186.6059,648.245,521.1478,169.8762,258.1555,752.9553,150.4378,393.5242,24.9103,346.0207,387.6504,290.3586,207.6037,86.7598,300.6876,268.9012,285.8059,271.7634,332.8458,249.2262,219.1486,261.525,317.0421,284.1693,371.4642,286.3775,299.591,283.8689,227.3961,291.1245,321.1809,259.6339,233.2071,341.4972,348.8483,249.6257,335.2654,242,221.6222,348.789,230.8343,287.1123,291.7051,269.5475,277.6975,293.1364,281.2389,289.4102,385.9782,353.1607,267.703,276.6077,290.4853,312.1567,337.7849,260.3319,310.146,294.691,246.3172,247.9418,280.1977,366.5351,235.7197,348.73,268.4072,216.7769,271.5753,208.5891,282.7648,231.551,285.9884,357.6434,311.754,298.7618,326.9826,342.3186,272.1986,258.8682,240.8268,386.9387,256.0128,271.6509,295.0917,349.6609,279.7912,319.2836,272.7684,303.5654,286.4964,276.9634,299.8863,225.1579,401.635,256.5313,314.9442,332.6272,271.9102,328.3724,262.5873,291.7422,273.9649,212.0843,356.7188,356.3877,237.7447,326.1452,302.1569,304.4165,354.7122,376.555,339.428,308.2172]}]}\n</script>\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}