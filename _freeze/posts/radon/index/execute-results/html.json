{
  "hash": "4c79e4a9c283b8374d8a888cfcfb839f",
  "result": {
    "markdown": "---\ntitle: \"Re-creating the `radon` teaching example with rstanarm and tidybayes\"\nexecute:\n  cache: false \ndate: \"2/15/2023\"\nauthor: \"Jon Zelner\"\nimage: \"radon_predictions.png\"\nbibliography: refs.bib\n---\n\n::: {.cell}\n\n:::\n\n\n# Introduction \n\nIn this tutorial, we are going to replicate the analysis of household-level variation in radon exposure originally presented in @gelman2006 (which is actually a tutorial version of @price1996). Our goal is to run the models described in the paper using regression models from base `R` as well as a Bayesian hierarchical model from the `rstanarm` package. Finally, we will reproduce Figures 1 & 2 from the original paper using `ggplot2`:\n\n![Original Fig 1 from [@gelman2006]](fig1.png)\n\n![Original Fig 2 from [@gelman2006]](fig2.png){width=50%}  \n\n\n## Preparing to run the examples\n\nTo be able to run the code below locally, please do the following:\n\n1. **Install or update to the latest version of RStudio.** The tutorial code will be contained in a Quarto markdown document. Quarto (which powers this very website!) is an updated version of the venerable RMarkdown, and the [newest versions of RStudio include Quarto support by default](https://quarto.org/docs/tools/rstudio.html). \n\n2. **Set up your R/RStudio installation to be able to load the following packages using the following code**:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ggplot2)\nlibrary(tidyr)\nlibrary(dplyr)\nlibrary(arm)\nlibrary(bayesplot)\nlibrary(rstanarm)\nlibrary(purrr)\nlibrary(tidybayes)\n```\n:::\n\n\nIf you are not sure if you have these installed or want to update to the latest versions, please paste this command into a running R session to download and install:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages(c(\"ggplot2\",\"tidyr\",\"dplyr\",\"bayesplot\",\"rstanarm\",\"purrr\",\"tidybayes\"))\n```\n:::\n\n\n3.[Download the zipfile](radon.zip) containing this tutorial, unzip it and open an R session inside this newly unzipped `radon` directory. \n\n# Fitting the models\n\n## Setting up the workspace\n\nFirst, we will load the relevant packages:\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ggplot2)\nlibrary(tidyr)\nlibrary(dplyr)\nlibrary(bayesplot)\nlibrary(rstanarm)\nlibrary(purrr)\nlibrary(tidybayes)\n```\n:::\n\n\n\n## Data Preparation\n\nFirst, lets take the raw `radon` dataset from the `rstanarm` package and recode the `floor` variable to be interpretable as the `basement` one from the original paper:  some minor modifications and additonal datasets that we'll use for the purposes of modeling and visualizing these data.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nradon$basement <- 1 - radon$floor\n```\n:::\n\n\nNow we can see that that the dataset has all of the variables we need:\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```\n  floor county  log_radon log_uranium basement\n1     1 AITKIN 0.83290912  -0.6890476        0\n2     0 AITKIN 0.83290912  -0.6890476        1\n3     0 AITKIN 1.09861229  -0.6890476        1\n4     0 AITKIN 0.09531018  -0.6890476        1\n5     0  ANOKA 1.16315081  -0.8473129        1\n6     0  ANOKA 0.95551145  -0.8473129        1\n```\n:::\n:::\n\n\n## ðŸšª Door 1: Full pooling!\n\nThis corresponds to a model in which we are assuming exactly no variation across locations in terms of the baseline level of radon. So, we can run a simple regression model where we assume that:\n\n$$\ny_{ij} = \\alpha + \\beta x_{ij} + \\epsilon_{i} \n$$\n\nWhere $x_{ij} = 1$ if a house has a basement and 0 otherwise.\n\nIn R, we can fit this model via least squares using a single line of code:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nm1 <-lm(log_radon ~ basement, data = radon)\n```\n:::\n\n\nWe can call the `summary` function to get a description of the key coefficients and the goodness-of-fit:\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```\nlm(formula = log_radon ~ basement, data = radon)\n            coef.est coef.se\n(Intercept) 0.78     0.06   \nbasement    0.59     0.07   \n---\nn = 919, k = 2\nresidual sd = 0.79, R-Squared = 0.07\n```\n:::\n:::\n\n\n## ðŸšª Door 2: No pooling\n\nThe second approach is the \"No Pooling\" one in which we allow the baseline intensity of radon in each county (represented by the intercept term $\\alpha_j$) to vary, but we don't do anything to constrain that variation. In other words, we treat each county as though it was independent. \n\nHowever, to estimate a consistent effect of having a basement across all counties, we estimate a single $\\beta$ term. This leads to a model that looks like this:\n\n$$\ny_{ij} = \\alpha_j + \\beta x_{ij} + \\epsilon_{i}\n$$\n\nIn `R` this is easy to implement, because we are implicitly asking the regression model to treat county as a categorical variable if we pass it to it as a `factor` datatype:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nno_pool_m <- lm(log_radon ~ basement + log_uranium + county, data = radon)\n```\n:::\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```\nlm(formula = log_radon ~ basement + log_uranium + county, data = radon)\n                     coef.est coef.se\n(Intercept)           0.42     0.37  \nbasement              0.69     0.07  \nlog_uranium           0.32     0.60  \ncountyANOKA           0.09     0.44  \ncountyBECKER          0.48     0.53  \ncountyBELTRAMI        0.67     0.43  \ncountyBENTON          0.39     0.48  \ncountyBIGSTONE        0.31     0.68  \ncountyBLUEEARTH       0.83     0.51  \ncountyBROWN           0.80     0.60  \ncountyCARLTON         0.05     0.38  \ncountyCARVER          0.43     0.50  \ncountyCASS            0.52     0.47  \ncountyCHIPPEWA        0.56     0.60  \ncountyCHISAGO         0.21     0.48  \ncountyCLAY            0.79     0.54  \ncountyCLEARWATER      0.28     0.50  \ncountyCOOK           -0.23     0.60  \ncountyCOTTONWOOD      0.06     0.63  \ncountyCROWWING        0.26     0.40  \ncountyDAKOTA          0.27     0.36  \ncountyDODGE           0.63     0.63  \ncountyDOUGLAS         0.60     0.49  \ncountyFARIBAULT      -0.42     0.57  \ncountyFILLMORE        0.18     0.75  \ncountyFREEBORN        0.94     0.51  \ncountyGOODHUE         0.80     0.48  \ncountyHENNEPIN        0.32     0.34  \ncountyHOUSTON         0.52     0.66  \ncountyHUBBARD         0.30     0.44  \ncountyISANTI          0.22     0.57  \ncountyITASCA          0.07     0.42  \ncountyJACKSON         0.83     0.59  \ncountyKANABEC         0.18     0.50  \ncountyKANDIYOHI       0.94     0.54  \ncountyKITTSON         0.51     0.55  \ncountyKOOCHICHING     0.04     0.52  \ncountyLACQUIPARLE     1.75     0.71  \ncountyLAKE           -0.40     0.44  \ncountyLAKEOFTHEWOODS  0.99     0.51  \ncountyLESUEUR         0.60     0.55  \ncountyLINCOLN         1.08     0.67  \ncountyLYON            0.75     0.59  \ncountyMAHNOMEN        0.23     0.84  \ncountyMARSHALL        0.53     0.44  \ncountyMARTIN         -0.05     0.51  \ncountyMCLEOD          0.17     0.46  \ncountyMEEKER          0.13     0.49  \ncountyMILLELACS      -0.07     0.60  \ncountyMORRISON        0.11     0.41  \ncountyMOWER           0.54     0.51  \ncountyMURRAY          1.27     0.90  \ncountyNICOLLET        0.99     0.59  \ncountyNOBLES          0.71     0.68  \ncountyNORMAN          0.10     0.63  \ncountyOLMSTED         0.16     0.48  \ncountyOTTERTAIL       0.60     0.40  \ncountyPENNINGTON      0.11     0.54  \ncountyPINE           -0.24     0.43  \ncountyPIPESTONE       0.62     0.68  \ncountyPOLK            0.55     0.60  \ncountyPOPE            0.11     0.70  \ncountyRAMSEY          0.22     0.33  \ncountyREDWOOD         0.78     0.61  \ncountyRENVILLE        0.46     0.67  \ncountyRICE            0.70     0.49  \ncountyROCK            0.06     0.79  \ncountyROSEAU          0.64     0.36  \ncountySCOTT           0.70     0.43  \ncountySHERBURNE       0.24     0.44  \ncountySIBLEY          0.10     0.58  \ncountySTLOUIS        -0.03     0.31  \ncountySTEARNS         0.38     0.43  \ncountySTEELE          0.41     0.53  \ncountySTEVENS         0.56     0.77  \ncountySWIFT          -0.18     0.61  \ncountyTODD            0.65     0.54  \ncountyTRAVERSE        0.76     0.69  \ncountyWABASHA         0.69     0.50  \ncountyWADENA          0.43     0.48  \ncountyWASECA         -0.47     0.58  \ncountyWASHINGTON      0.31     0.34  \ncountyWATONWAN        1.54     0.60  \ncountyWILKIN          1.06     0.86  \ncountyWINONA          0.41     0.60  \ncountyWRIGHT          0.59     0.39  \n---\nn = 919, k = 86\nresidual sd = 0.73, R-Squared = 0.29\n```\n:::\n:::\n\n\n\n## ðŸšª Door 3: Partial Pooling {#sec-partial}\n\nFinally, we get to the partial pooling, hierarchical model in which we introduce a *hierarchical prior* to the model to allow our model to shrink observations from places with few observations towards the population mean. This allows us to avoid the pitfalls of overfitting associated with the no-pooling approach while not making the homogeneity assumptions associated with the full-pooling approach.\n\nThis works out to a *multi-level* model that allows random variation in household-level radon measurements as well as variation at the county level in radon levels above or below the amount predicted by the county-level soil uranium measure. Much like the no-pooling model, we can write outcomes for *individuals* as:\n\n$$\ny_{ij} = \\alpha_j + \\beta x_{ij} + \\epsilon_{i}\n$$\n\nHowever, rather than stopping there, we introduce a second level of random variation to the county-level *intercepts*, $\\alpha_j$.\n\n$$\n\\alpha_j = \\gamma_0 + \\gamma \\zeta_{j} + \\epsilon_{j}\n$$\n\nWhere $\\epsilon_i \\sim N(0, \\sigma_i)$ and $\\epsilon_j \\sim N(0, \\sigma_j)$.\n\nTo fit this model, we'll use the `rstanarm` package, which uses the Stan Bayesian modeling language under the hook to fit the model. This model introduces another piece of syntax to our equation, which now reads `log_radon ~ basement + log_uranium + (1 | county)`. The interesting part of this is the `(1 | county)` which is a syntax used by `rstanarm` and other hierarchical modeling packages (such as `lme4`) to specify random intercepts (typically represented by a 1 in the matrix of regressors) for each of a set of clusters, in this case counties. In this model, the county-level intercept terms are implicitly assumed to be normally distributed with unknown variance $\\sigma_j$ which will be estimated when the model is fit. \n\nWe use the `stan_lmer` function to fit a hierarchical linear model with a normally-distributed response variable, as follows:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nm2 <- stan_lmer(log_radon ~ basement + log_uranium + (1 | county), data = radon)\n```\n:::\n\n\nBecause this model is fit by MCMC, we can use draws from the posterior distribution to understand uncertainty in the model. For example, this visualization of the median prediction and credible intervals for the basement and uranium effects can be visualized using the `mcmc_areas` function from the `bayesplot` package:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nposterior <- as.matrix(m2)\ng2 <- mcmc_areas(posterior, pars = c(\"basement\", \"log_uranium\"))\nplot(g2)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-11-1.png){width=672}\n:::\n:::\n\n\n\n# Making the Figures\n\n## Figure 1\n\n### Data Preparation\n\nSince each row of `radon` dataset includes an observation of a single house, we need to work backwards to obtain the county-level soil uranium measure for each individual county. This is pretty straightforward to do using the `dplyr` package:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncounty_uranium <- radon %>%\n  group_by(county) %>%\n  summarize(log_uranium = first(log_uranium)) \n```\n:::\n\n\nWe will also make a second dataset that we will use for storing the predicted radon levels for households with and without basements each for county. This contains 2 entries for each county, representing observations taken in the basement or on the first floor.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncounty_uranium_tmp_1 <- county_uranium\ncounty_uranium_tmp_1$basement <- 1\ncounty_uranium_tmp_2 <- county_uranium\ncounty_uranium_tmp_2$basement <- 0\n\ncounty_dummy_df <- rbind(county_uranium_tmp_1, county_uranium_tmp_2)\n```\n:::\n\n\nNow, we will take each of our fitted models (fully pooled, unpooled and partially pooled) and put their predicted values into our plotting dataset\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncounty_dummy_df$pooled_pred <- predict(m1, county_dummy_df)\ncounty_dummy_df$no_pool_pred <- predict(no_pool_m, county_dummy_df)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning in predict.lm(no_pool_m, county_dummy_df): prediction from a rank-\ndeficient fit may be misleading\n```\n:::\n:::\n\n\nBecause the partial pooling model was fit using MCMC, we will take a slightly different approach and use the median of the posterior predictive distribution for each observation, which is analogous to (but not exactly the same as) the OLS predictions from the other models:\n\n::: {.cell}\n\n```{.r .cell-code}\n## Gives posterior median for each prediction.\ncounty_dummy_df$partial_pred <- posterior_predict(m2, county_dummy_df) %>%\n  apply(2,median) \n```\n:::\n\n\n### Plotting\n\nTo re-create Figure 1, we will subset out the observed data and predictions for the 8 counties included in the original figure:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Place the county names in a vector we will use to keep track of them\nfig_1_counties <-\n  c(\n    \"LACQUIPARLE\",\n    \"AITKIN\",\n    \"KOOCHICHING\",\n    \"DOUGLAS\",\n    \"CLAY\",\n    \"STEARNS\",\n    \"RAMSEY\",\n    \"STLOUIS\"\n  )\n\n\n# First, using the `county_dummy_df` with the basement/non-basement predictions in it,\n# subset out the relevant counties and make a new county factor variable which\n# will be used to ensure that the counties in Fig. 1 plot in the right order\n\ncounty_df_fig_1 <- county_dummy_df %>%\n  filter(county %in% fig_1_counties) %>%\n  mutate(county2 = factor(county, levels = fig_1_counties)) %>%\n  arrange(county)\n\n## Now select out the households in the original data that\n## are in each county and create another county-level factor\n## variable in the same order\n\npred_counties <- radon %>% filter(county %in% fig_1_counties) %>%\n  mutate(county2 = factor(county, levels = fig_1_counties))\n```\n:::\n\n\nOnce we have the datasets together for the figure, we can begin constructing it using `ggplot2`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ng <- ggplot() +\n  ## The geom_jitter geom plots the log_radon values for each household and \n  ## jitters the points slightly to avoid overplotting. \n  geom_jitter(\n    data = pred_counties,\n    aes(x = basement, y = log_radon, group = county2),\n    height = 0,\n    width = 0.1\n  ) +\n  \n  ## This superimposes the partial-pooling (Î± + Î² x_i + Ïµ_i +Ïµ_j) predictions\n  ## over the raw data\n  geom_line(\n    data = county_df_fig_1,\n    aes(x = basement, y = partial_pred, group = county2),\n    linetype = \"solid\",\n    colour = \"gray\"\n  ) +\n  \n  ## No-pooling predictions (Î±_{ij} + Î² x_i + Ïµ_i)\n  geom_line(\n    data = county_df_fig_1, \n    aes(x = basement, y = no_pool_pred, group = county2)\n  ) +\n  \n  ## Full pooling predicitons (Î± + Î² x_i + Ïµ_i)\n  geom_line(\n    data = county_df_fig_1,\n    aes(x = basement, y = pooled_pred, group = county2),\n    linetype = \"dashed\"\n  ) +\n  \n  ## Finally, use facet_wrap to arrange the panels in two \n  ## rows of four\n  facet_wrap(vars(county2), nrow = 2) +\n  xlab(\"basement\") +\n  ylab(\"log radon level\") +\n  theme_bw() +\n  theme(panel.grid.major = element_blank(),\n        panel.grid.minor = element_blank())\n\nplot(g)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-17-1.png){width=672}\n:::\n:::\n\n\n## Figure 2 \n\nFigure 2 reproduces the relationship between the county-level random intercepts, $\\alpha_j$ and the expected level of radon at a county level as a function of county-level soil uranium. \n\n### Data Preparation\n\nThe following code allows us to extract predictions at the county level using our prediction dataset. To do this, we use the `predicted_draws` function from the `tidybayes` package, which lets us sample from the posterior distribution of the fitted model. The `median_qi` function, also from tidybayes, lets us calculate the width of a 1 standard error interval (equivalent to the range containing ~17% of the posterior probability mass around the posterior median) used in the original Figure 1 from @gelman2006:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndd <- predicted_draws(m2, county_dummy_df) %>%\n  median_qi(.width = 0.17) %>%\n  filter(basement == 0)\n```\n:::\n\n\nIn order to calculate the predicted mean radon at a county level, we need to access the coefficients corresponding to the level two model, including the intercept $\\gamma_0$ and the effect of a 1-log change in log-uranium on predicted log-radon, $\\gamma_1$. In order to get these values out of the model, we can use the `gather_draws` function from tidybayes,  which allows us to access the posterior distributions for each of these parameters: \n\n\n::: {.cell}\n\n```{.r .cell-code}\nuranium_coefs <-\n  gather_draws(m2, c(`(Intercept)`, log_uranium)) %>% median_qi()\n```\n:::\n\n\nNow it is as simple as calculating the linear predictor $\\gamma_0 + \\gamma_1 z_j$, where $z_j$ is the log-uranium measure for the j-th county, and storing this information in a data frame we will use for plotting:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlog_uranium_range <-\n  seq(min(county_uranium$log_uranium) - .1,\n      max(county_uranium$log_uranium) + .1,\n      by = 0.1)\n\npred_log_radon <-\n  uranium_coefs$.value[1] + uranium_coefs$.value[2] * log_uranium_range\n\nmedian_radon_pred <-\n  data.frame(log_uranium = log_uranium_range, .prediction = pred_log_radon)\n```\n:::\n\n\n### Plotting\n\nNow, we can build this figure up one step at a time, starting with our mean predictions:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ng <- ggplot(dd) +\n     geom_line(data = median_radon_pred, aes(x = log_uranium, y = .prediction)) \n\nplot(g)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-21-1.png){width=672}\n:::\n:::\n\n\nThe next step is to then add the median predictions (points) and 1 SE errorbars to the plot, and then fix the theme to match the original figure, et voilÃ ! \n\n\n::: {.cell}\n\n```{.r .cell-code}\ng <- g +  geom_point(aes(x = log_uranium, y = .prediction, group = county)) +\n  geom_errorbar(aes(\n    x = log_uranium,\n    y = .prediction,\n    ymin = .lower,\n    ymax = .upper\n  )) +\n  theme_bw() + theme(panel.grid.major = element_blank(),\n                     panel.grid.minor = element_blank()) +\n  xlab(\"county-level uranium measure\") +\n  ylab(\"regression intercept\")\n\nplot(g)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-22-1.png){width=672}\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}